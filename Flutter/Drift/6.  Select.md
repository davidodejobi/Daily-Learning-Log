# Drift **SELECT** Cheatâ€‘Sheet â€“ Quiver

Learn to fetch your StudyÂ Sets, Topics, Flashcards, Summaries, Quizzes & Progress rows with expressive, typeâ€‘safe Dart instead of raw SQL.

---

## 1Â Quick patterns

| What you need | Drift call                                                      |
| ------------- | --------------------------------------------------------------- |
| **All rows**  | `select(studySets).get()`                                       |
| **Stream**    | `select(topics).watch()` â€“ autoâ€‘updates UI on change            |
| **Single**    | `select(flashcards)..where((f) => f.id.equals(id)).getSingle()` |
| **Paginate**  | `(select(summaries)..limit(20, offset: page*20)).get()`         |

---

## 2Â Filtering (`where`)

```dart
final recent = DateTime.now().subtract(const Duration(days:Â 7));
(select(quizzes)
  ..where((q) => q.createdAt.isBiggerOrEqualValue(recent)))
  .watch();
```

Combine: `&` (AND), `|` (OR), `a.not()`.

## 3Â Ordering

```dart
(select(flashcards)
  ..orderBy([(f)=>OrderingTerm.desc(f.easeFactor)]))
  .get();
```

Nullable hint â‡’ `f.due.asc(nulls:Â NullsOrder.last)`

## 4Â Limiting

`..limit(50, offset: 0)` â€“ great for infinite scroll.

---

## 5Â Singleâ€‘value helpers

* `getSingle()` / `watchSingle()` â€“ guarantees 0â€‘orâ€‘1 rows.
* `getSingleOrNull()` when row might be absent.

---

## 6Â Joins

```dart
final q = select(topics).join([
  leftOuterJoin(studySets, studySets.id.equalsExp(topics.studySetId)),
]);
q.watch().map((rows) => rows.map((r) => (
  topic: r.readTable(topics),
  set:   r.readTableOrNull(studySets),
)));
```

Use `alias(table, 't2')` if same table twice.

### Prefilter & order across tables

```dart
q.where(studySets.title.like('%Algorithms%'));
q.orderBy([OrderingTerm.asc(studySets.title)]);
```

---

## 7Â GroupÂ By / Aggregates

Count flashcards per topic:

```dart
final cnt = flashcards.id.count();
final q = select(topics)
  ..addColumns([cnt])
  ..join([
    innerJoin(flashcards, flashcards.topicId.equalsExp(topics.id), useColumns:false)
  ])
  ..groupBy([topics.id]);
final rows = await q.get();
// rows[i].read(cnt) gives int
```

Average easeFactor overall:

```dart
final avgEase = flashcards.easeFactor.avg();
await (selectOnly(flashcards)..addColumns([avgEase])).watchSingle();
```

---

## 8Â Subqueries & EXISTS

Missingâ€‘due flashcards per set:

```dart
final due = flashcards.due.isSmallerOrEqualValue(DateTime.now());
final sub = select(flashcards)..where(due);
final hasDue = existsQuery(sub);
return (select(studySets)..addColumns([hasDue])).map((r)=>
  (set: r.readTable(studySets), due: r.read(hasDue)!)
).watch();
```

---

## 9Â Insertâ€‘fromâ€‘select (bulk copy)

Duplicate all flashcards from one topic to another:

```dart
final src = select(flashcards)..where((f)=>f.topicId.equals(srcId));
await into(flashcards).insertFromSelect(src, columns:{
  flashcards.topicId: Variable<int>(destId),
  flashcards.front:   flashcards.front,
  flashcards.back:    flashcards.back,
});
```

---

## 10Â Compoundâ€¯UNION | EXCEPT | INTERSECT

All unique tags used in summaries **and** flashcards:

```dart
final sTags = selectOnly(summaryTags)..addColumns([summaryTags.tag]);
final fTags = selectOnly(flashcardTags)..addColumns([flashcardTags.tag]);
final union = sTags.unionAll(fTags);
final results = await union.get();
```

---

## 11Â JSON tricks (optional)

Store flexible meta inside a JSON `extras` column and query parts with `jsonExtract` or `jsonEach`.

---

### Tips

* **Streams inside transactions** autoâ€‘close; build UI streams outside transactions.
* Use `Selectable` base classes to expose queries flexibly without locking to Future vs Stream.
* Wrap long multiâ€‘step reads in `transaction(() async { ... })` if you need consistent snapshot.

Ready to wire into Quiverâ€”grab snippets as needed ðŸš€
