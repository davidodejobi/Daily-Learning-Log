# Drift **Views** ‚Äì Quick¬†Guide for **Quiver**

> Turn complex SELECTs into reusable, read‚Äëonly ‚Äúvirtual tables.‚Äù Great for dashboards (e.g., *`TopicStatsView`* showing flashcard/quiz counts) or speeding up joins.

---

## 1¬†Why use a View?

* **Re‚Äëuse:** Encapsulate heavyweight joins so UI/DAO code stays tidy.
* **Performance:** SQLite stores the compiled plan; fewer round‚Äëtrip strings.
* **Migration‚Äësafe:** Drift rebuilds the view when schema changes.

---

## 2¬†Anatomy of a Dart View

```dart
// ‚ë† Extend `View` in an *abstract* class
abstract class TopicStatsView extends View {
  // ‚ë° List tables it reads (getters)
  Topics get topics;          // your table class
  Summaries get summaries;    // etc.
  Flashcards get flashcards;
  Quizzes get quizzes;

  // ‚ë¢ Expression getters become columns
  Expression<int> get summaryCount => summaries.id.count();
  Expression<int> get flashcardCount => flashcards.id.count();
  Expression<int> get quizCount => quizzes.id.count();

  @override
  Query as() => select([
        topics.id,           // Pass‚Äëthrough columns
        topics.title,
        summaryCount,
        flashcardCount,
        quizCount,
      ])
      .from(topics)
      .join([
        leftOuterJoin(summaries, summaries.topic.equalsExp(topics.id)),
        leftOuterJoin(flashcards, flashcards.topic.equalsExp(topics.id)),
        leftOuterJoin(quizzes, quizzes.topic.equalsExp(topics.id)),
      ]);
}
```

**Key points**

1. **Abstract class** ‚Äì no boilerplate, Drift generates row class (e.g. `TopicStatsViewData`).
2. **Table getters** ‚Äì just names; Drift injects real instances.
3. **Expression getters** ‚Äì any SQL expression allowed (`count()`, `avg()`, JSON ops‚Ä¶). Always nullable.
4. **as()** ‚Äì returns a `Query`; `select([...]).from().join()` just like hand‚Äëwritten select.

---

## 3¬†Register the View

```dart
@DriftDatabase(
  tables: [Topics, Summaries, Flashcards, Quizzes],
  views:  [TopicStatsView],
)
class AppDatabase extends _$AppDatabase { ... }
```

Drift now generates:

* `TopicStatsViews` table‚Äëlike getter on your `AppDatabase`.
* Row class `TopicStatsViewData` with columns: `id`, `title`, `summaryCount`, etc.

---

## 4¬†Querying a View

```dart
// DAO or anywhere with db access
Stream<List<TopicStatsViewData>> watchTopicStats() =>
    db.select(db.topicStatsView).watch();

Future<TopicStatsViewData?> statsForTopic(int id) =>
    (db.select(db.topicStatsView)..where((row) => row.id.equals(id))).getSingleOrNull();
```

> Views are **read‚Äëonly** ‚Äì use them for analytics, not inserts/updates.

---

## 5¬†Column Nullability Rules

| Column origin                                              | Nullable?                      |
| ---------------------------------------------------------- | ------------------------------ |
| Expression getter (e.g. `summaryCount`)                    | **Always** `nullable` (`int?`) |
| Pass‚Äëthrough column on **primary table** (first in `from`) | Mirrors original nullability   |
| Column via **outer join**                                  | Nullable (row may be null)     |

---

## 6¬†Advanced Tips

* **Parameterized views?** Use a DAO method instead (views cannot accept params).
* **Materialized cache**: If a view gets expensive, create a *table* and refresh via triggers.
* **Testing**: query the view in unit tests to catch join/alias issues before shipping.

---

### üöÄ Quiver Example Ideas

| View                  | Use‚Äëcase                                                                  |
| --------------------- | ------------------------------------------------------------------------- |
| `StudySetOverview`    | summaries/flashcards/quizzes counts per study‚Äëset for Home screen cards.  |
| `DailyProgressView`   | Join `progress` + `topics` to show today‚Äôs completion % in analytics tab. |
| `UnsyncedChangesView` | Filter outbox rows for quick ‚Äúpending sync‚Äù badge.                        |

Use views to keep UI code declarative and avoid duplicating monster joins.
