# Drift **Writes** â€“ Quick Guide for **Quiver**

Master inserts, updates, deletes, upserts, and batch ops so your offlineâ€‘first data stays consistent and syncâ€‘ready.

---

## 1Â Row vs. Companion ðŸ§

| Useâ€‘case              | Class                  |
| --------------------- | ---------------------- |
| **Read** / full row   | `StudySet` (row class) |
| **Write** partial row | `StudySetsCompanion`   |

`Value.absent()` says â€œdonâ€™t touch this column.â€ `Value(null)` sets it to **NULL**.

---

## 2Â Inserts

```dart
// 2.1  Single insert â€“ required cols only
final id = await into(studySets).insert(
  StudySetsCompanion.insert(
    title: 'Physics â€“ Optics',
    ownerId: currentUserId,
  ),
);

// 2.2  Bulk insert via batch â€“ âš¡ fastest for imports
await batch((b) => b.insertAll(
  flashcards,
  parsedCsv.map((f) => FlashcardsCompanion.insert(
        topicId: topicId,
        front: f.front,
        back: f.back,
      )),
));

// 2.3  insertReturning â€“ grab auto IDs & defaults (requires sqlite â‰¥â€¯3.35)
final newTopic = await into(topics).insertReturning(
  TopicsCompanion.insert(
    studySetId: id,
    title: 'Snellâ€™s Law',
  ),
);
```

### Upsert (insertâ€‘orâ€‘update)

```dart
await into(progress).insert(
  ProgressCompanion.insert(
    userId: uid,
    flashcardId: cardId,
    score: 1,
  ),
  onConflict: DoUpdate(
    (old) => ProgressCompanion.custom(
      score: old.score + const Constant(1),
    ),
    // uses PK by default; supply `target:` for UNIQUE combos
  ),
);
```

---

## 3Â Updates

```dart
// 3.1  Field patch â€“ move all â€˜draftâ€™ summaries to â€˜finalâ€™
await (update(summaries)
      ..where((s) => s.status.equals('draft')))
    .write(SummariesCompanion(status: const Value('final')));

// 3.2  SQL expression update â€“ increment review count inâ€‘place
await (update(flashcards)
      ..where((f) => f.id.isIn(cardIds)))
    .write(FlashcardsCompanion.custom(
      reviewCount: flashcards.reviewCount + const Constant(1),
    ));

// 3.3  Replace whole row (using primary key under the hood)
await update(topics).replace(topic.copyWith(title: 'Updated'));  
```

---

## 4Â Deletes

```dart
// Soft delete pattern (recommended for sync)
await (update(studySets)..where((s) => s.id.equals(id)))
  .write(StudySetsCompanion(archivedAt: Value(DateTime.now())));

// Hard delete â€“ be cautious!  No `where` â‡’ all rows wiped
await (delete(progress)..where((p) => p.userId.equals(uid))).go();
```

---

## 5Â Batch vs. Transaction

* **Batch** â‡’ prepares each statement once â†’ âš¡ best for bulk writes.
* **Transaction** â‡’ ensures *all* writes commit together.  Batches can run inside a `transaction(() async { â€¦ })` for atomic bulk imports.

```dart
await transaction(() async {
  await batch((b) {
    b.insertAll(summaries, summaryCompanions);
    b.insertAll(flashcards, flashCompanions);
  });
  // Any additional logicâ€¦
});
```

---

## 6Â Best Practices for Quiver Sync

1. **Outbox table** â€“ log every local mutation (`mutation_type`, `row_id`, `payload`) so background sync can POST to Supabase when online.
2. **Triggers** â€“ after INSERT/UPDATE/DELETE on main tables, insert a row into `outbox`.
3. **Conflictâ€‘free ID strategy** â€“ use `uuid_v4()` clientâ€‘side to avoid clashes before server push.
4. **Soft deletes** â€“ mark as `archived_at` instead of hard delete; resolve on server.

---

## 7Â Common Write Snippets

| Scenario                   | Code                                                                                    |
| -------------------------- | --------------------------------------------------------------------------------------- |
| **Mark flashcard correct** | `(update(progress)..whereSameRow(p)).write(ProgressCompanion(score: Value(p.score+1)))` |
| **Duplicate studyâ€‘set**    | `await transaction(() async { â€¦copy rows, maintain new UUIDsâ€¦ })`                       |
| **Import CSV**             | `await batch((b)=>b.insertAllBulk(flashcards, parsed))`                                 |

---

### TL;DR

* Use **companions** for all writes.
* Wrap bulk ops in **batch** inside a **transaction**.
* Prefer **upsert** for idempotent sync.
* Never run update/delete without a **where**!

Happy writing ðŸŽ‰
